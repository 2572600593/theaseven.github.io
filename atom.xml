<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>霓裳LaoA的小苑</title>
  
  
  <link href="https://theaseven.github.io/atom.xml" rel="self"/>
  
  <link href="https://theaseven.github.io/"/>
  <updated>2021-01-08T08:31:41.296Z</updated>
  <id>https://theaseven.github.io/</id>
  
  <author>
    <name>LaoA</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构复习整理</title>
    <link href="https://theaseven.github.io/2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://theaseven.github.io/2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-01-06T03:55:24.000Z</published>
    <updated>2021-01-08T08:31:41.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习整理"><a href="#数据结构复习整理" class="headerlink" title="数据结构复习整理"></a>数据结构复习整理</h1><p>1.选A。</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210101164202145.png" style="zoom: 80%;" /><img src="C:\Users\user\Desktop\数据结构知识梳理\img source\删除A结点.png" alt="删除A结点" style="zoom: 67%;" /><p>2.设有n个待排序的记录关键字，则在堆排序中需要（1）个辅助记录单元。</p><p>堆排序属于就地排序，空间复杂度为O(1)，只需要一个辅助空间，记录当前操作二叉树的根节点的数值。</p><p>3.快排一次的结果，选A。</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210101165513209.png" alt="image-20210101165513209" style="zoom:67%;" /><p>分别从初始序列“<strong>20，15，14，18，21，36，40，10；</strong>”两端开始“探测”。先从右往左找一个<strong>小于等于</strong>20的数，再从左往右找一个<strong>大于等于</strong>20的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边（i）和最右边（j）。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字<strong>20</strong>。让哨兵j指向序列的最右边（即j=8），指向数字<strong>10</strong>。  </p><p>具体步骤：<br>  1.哨兵j一步一步地向左挪动（即j–），直到找到一个小于<strong>20</strong>的数（10）停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于<strong>20</strong>的数（21）停下来，然后交换两者位置，即‘<strong>20，15，14，18，10，36，40，21</strong>’  。<br>  2.重复1，即哨兵j向左找小于<strong>20</strong>的数（指向<strong>10），</strong>同时哨兵i指向<strong>10，此时哨兵i和哨兵j相遇</strong> （即满足了i=j,），将基准数<strong>20</strong>和当前相遇位置（i=j）指向的数<strong>10</strong>进行交换，即‘<strong>10，15，14，18，20，36，40，21</strong>’.至此第一趟快排结束。</p><p>4.设二叉排序树有n个结点，则<strong>二叉排序树的平均查找长度</strong>为O(log2n)。</p><p>5.选D</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210101170909773.png" alt="image-20210101170909773" style="zoom:67%;" /><p>表头结点(由点个数决定)：n；表(弧)结点(由边个数决定，因为是无向图，每条边相当于双向)：2e。</p><p>6.强连通图有n个顶点，则至少有n条边。</p><blockquote><p>在有向图G中，如果对于每一对vi、vj，vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。<br>要使得强连通图的边最少，我们得让这些顶点成环，所以至少得有n条边。</p></blockquote><p>7.常见排序的时间、空间复杂度</p><table><thead><tr><th>排序方法</th><th>时间复杂度(平均)</th><th>时间复杂度(最坏)</th><th>时间复杂度(最好)</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>快速排序</td><td>O(nlog2n)</td><td>O(n^2)</td><td>O(nlog2n)</td><td>O(log2n)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(n)</td><td>稳定</td></tr></tbody></table><p>8.数据的物理结构主要包括<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>。</p><p>9.<strong>深度为k的完全二叉树</strong>，至少有2^(k-1)个结点，最多有2^k-1个结点。</p><p>​    若用二叉链表作为有n个结点的完全二叉树的存储结构，则共有n+1个空指针域。</p><p>​    <strong>深度为k的二叉树</strong>，至少有k个结点（一条链），最多有2^k-1个结点（满二叉树）。</p><p>10.设输入序列为 1   2   3 ,则经过栈的作用后可以得到（5）种不同的输出序列。</p><p>​    利用<strong>卡特兰数</strong>公式f(n) = C(2n,n)/(n+1),带入n等于3得到f(3) = 5。</p><img src="C:\Users\user\Desktop\数据结构知识梳理\img source\C.png" alt="C" style="zoom: 33%;" /><p>11.设有向图 G 用邻接矩阵 A[n] [n] 作为存储结构, 则该邻接矩阵中<strong>第 i 行上所有元素之和</strong>等于<strong>顶点 i 的出度</strong> ,<strong>第 i 列上所有元素之和</strong>等于<strong>顶点 i 的入度</strong>。</p><p>12.哈夫曼树，又称最优二叉树，是指对于一组带有确定权值的叶子结点所构造的具有带权路径长度最短的二叉树。<strong>哈夫曼树没有度数为1的结点</strong>。</p><p>13.设有 n 个结点的完全二叉树, 如果按照从自上到下、从左到右从 1 开始顺序编号, 则第 i 个结点的父亲结点编号为 i/2 ,左孩子为 2i，右孩子为 2i+1。</p><p>​    具有n个结点的完全二叉树的深度为log2n+1（log2n向下取整）。</p><p>14.<strong>如果一个有向图不存在回路，则该图的全部顶点可以排列成一个拓扑排序</strong>。</p><p>设有向图G中有向边的集合E ={&lt;1 , 2&gt; , &lt;2 , 3&gt; , &lt;1 , 4&gt; , &lt;4 , 2&gt; , &lt;4 , 3&gt;} ,则该图的一种<strong>拓扑序列</strong>为(1,4,2,3)。</p><p>​    <strong>方法</strong>：    </p><p>​    现根据题目做出1 2 3 4之间的关系图：</p><img src="C:\Users\user\Desktop\数据结构知识梳理\img source\关系.png" alt="关系" style="zoom:50%;" /><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210104211357927.png" alt="image-20210104211357927" style="zoom: 57%;" /><p>15.典型算法的时间复杂度</p><table><thead><tr><th>算法</th><th>时间复杂度</th></tr></thead><tbody><tr><td>Dijkstra</td><td>O(n^2)</td></tr><tr><td>Prim</td><td>O(n^2)</td></tr><tr><td>Kruskal</td><td>O(elog2e)   （e为边数）</td></tr><tr><td>BFS、DFS</td><td>O(n+e)</td></tr></tbody></table><p>16.一棵m阶的<strong>B-树</strong>中，结点关键字个数最多有m-1个。</p><p>​    一棵m阶的B-树，<strong>或为空树</strong>，或为满足下列特性的m叉树：</p><p>​    1.树中每个结点至多有m棵子树。</p><p>​    2.若根结点不是叶子结点，则至少有两棵子树。</p><p>​    3.除根之外的所有非终端结点至少有m/2(向上取整)棵子树。</p><p>​    4.所有叶子结点都在同一层。</p><p>17.n个结点的无向连通图，至少有n-1条边，最多有n(n-1)/2条边。</p><p>具有6个顶点的无向图最少5条边可以形成连通图，至少需要11条边才能<strong>确保</strong>是连通图。</p><p>​    对于确保是连通图，做法就是先使n-1条边完全连通，再附加一条边连接另一个点。此题n-1为5，5(5-1)/2=10,再加1条，即为11条边。</p><img src="C:\Users\user\Desktop\数据结构知识梳理\img source\无向连通图.png" alt="无向连通图" style="zoom:67%;" /><p>18.<strong>逻辑结构与物理结构</strong></p><p>​    <strong>1.逻辑结构：所谓逻辑结构就是数据与数据之间的关联关系，准确的说是数据元素之间的逻辑关系。</strong></p><p>​        逻辑结构有四种基本类型：集合，线性结构，树型结构，图状结构。<br>​        也可以统一的分为线性结构和非线性结构。</p><blockquote><p>注：所有的数据都是由数据元素构成，数据元素是数据的基本构成单位。而数据元素由多个数据项构成。 </p><p>数据对象是性质相同的数据元素的集合，是数据的一个子集。</p></blockquote><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210103122311194.png" alt="image-20210103122311194" style="zoom: 53%;" /><p>​    <strong>2.物理结构(存储结构)： 数据的物理结构就是数据存储在磁盘中的方式。</strong><br>​        包括：顺序存储，链式存储，散列，索引</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210102131010040.png" alt="image-20210102131010040" style="zoom: 67%;" /><blockquote><p> 对于线性表，从存储结构上分，可以有顺序存储结构和链式存储结构。<br> 顺序存储结构包括顺序表、顺序队列和顺序栈；链式存储结构包括链表、链队列和链栈。</p></blockquote><p>19-1.假设以行优先顺序存储<strong>三维数组</strong>A[5] [6] [7]，其中元素A[0] [0] [0]的地址为1100，且每个元素占2个存储单元，则A[4] [3] [2]的地址是(1482)。</p><p>​    解：4 * (6 * 7)+(3 * 7)+2 = 191</p><p>​        每个元素占两个存储单元，地址为：191*2 + 1100 = 1482</p><p>19-2.若三维数组a[4] [5] [6]的基地址是100,每个元素占用2个存储单元,则数组a中最后一个元素的存储地址是(338).</p><p>​    解：数组a的最后一个元素为a[3] [4] [5]。</p><p>​        3 * (5 * 6)+(4 * 6)+5 = 119</p><p>​        每个元素占两个存储单元，地址为：119*2 + 100 = 338</p><p>20.在<strong>堆排序</strong>过程中，对任一分支节点进行筛运算时间复杂度为O(log2n)，整个堆排序为O(nlog2n)。</p><p>21.<strong>算法质量</strong>的4个方面：正确 易读 强壮 高效。</p><p>​    <strong>算法的特点</strong>：有穷性，确定性，可行性，输入性，输出性</p><p>22.AOV网是有向无环图。</p><p>​    在AOV网的边上加上权值，称其为AOE网。</p><p>​    在AOE网中，<strong>从始点到终点具有最大路径长度的路径</strong>为关键路径。</p><p>23.<strong>克鲁斯卡尔</strong>求最小生成树：</p><p>​    1.根据边集写出权值从小到大的各边起点和终点。<br>​    2.按权值从小到大进行连接作图，遇闭环则跳过。</p><p>24.<strong>哈夫曼树</strong>是正则二叉树，只有度为0、2的结点，且有<strong>二叉树的性质：n0 = n2 + 1</strong>。</p><p>​    若用二叉链表存哈夫曼树，空指针 = 总结点 + 1。</p><p>​    <strong>哈夫曼树的建立：</strong><br>​    1.在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和。<br>​    2.再选出最小的两个权值(包括上面得到的根结点的权值)，组成二叉树，重复上述此过程可建立哈夫曼树。</p><p>​    <strong>哈夫曼编码：</strong>左孩子分支标0，右孩子分支标1。</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210102130143528.png" alt="image-20210102130143528" style="zoom:67%;" /><p>​    <strong>哈夫曼树的带权路径长度：</strong></p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210104195829167.png" alt="image-20210104195829167" style="zoom: 67%;" /><p>25.某个结点的<strong>平衡因子</strong>就是那个结点的左子树高度 - 右子树高度（可能为负值）。</p><p>26.<strong>平衡二叉树</strong>又称为AVL树，性质：它是一棵<strong>空树</strong>或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>27.关键字序列为：{38，25，74，63，52，48}，哈希函数为H(k)=k%7,哈希表的长度为7，用线性探测法处理冲突，构造<strong>哈希表</strong>并计算查找成功的平均查找长度。</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210102111227437.png" alt="image-20210102111227437" style="zoom:80%;" /><p>28.<strong>希尔排序</strong>：增量为3，则把下标相差3的分为一组（1和4相差3）。对每一组分别排序后再插入，即得到一趟排序的结果。</p><p>29.<strong>堆排序建立初始大顶堆</strong>：先按照关键字顺序做出完全二叉树，再检测右、左、根树是否满足大顶堆的特性，若不满足则互换元素位置。根结点排完后再检查改变过的子树，再进行调整。</p><p>题目是(48， 80， 52， 35 ，41 ，90)，利用堆排序建立的初始大根堆是：(90  80  52  35  41  48)，过程如下：</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210102114850462.png" alt="image-20210102114850462"></p><p>30.<strong>二叉排序树的建立：</strong>第一个关键字作根节点，按顺序从上往下建立，遵循左小右大的原则。</p><p>​    <strong>删除</strong>根结点：删除后寻找左子树数值最接近根结点 或 右字子树数值最接近根结点的数，放到根位置，并调整原位置的各点。（查找方式：左子树右分支的尽头、右子树左分支的尽头）</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210103125106416.png" alt="image-20210103125106416" style="zoom: 35%;" /><p>31.图的<strong>DFS、BFS</strong>遍历序列（bfs用到队列，出队时相邻点顺序入队）</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210102123404821.png" alt="image-20210102123404821"  /><p>​    解答：</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210102123447112.png" alt="image-20210102123447112" style="zoom:67%;" /><p>32.<strong>Prim算法</strong>生成最小生成树：</p><p>从起点开始，选择距离起点<strong>最近的点</strong>连接，之后每次选择 <strong>距离已经选择的点 最近的点</strong>进行连接，当所有点都被连接，就生成了最小生成树。</p><p>33.<strong>算法设计</strong>：</p><p>​    1.<strong>设计判断二叉树是否为二叉排序树的算法</strong>。</p><p>二叉排序树特点：左孩子 &gt; 根结点 &gt; 右孩子，并且<strong>中序遍历二叉排序树时，得到的序列是一个严格递增的序列</strong>。所以我们可以以此来判断二叉树是否为二叉排序树。<br> 设置一个比所有结点值最小值还小的一个值，与结点从小到大做判断即可。如果最小值比判断的值大，则说明不是二叉排序树；如果最小值比判断的值小，则接着往下做判断，直到树的最后一个结点。如果是二叉排序树，则最小值应该是最左侧的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> minnum=<span class="number">-32768</span>,flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> key; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;bitree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(bitree *bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bt!=<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">inorder(bt-&gt;lchild); </span><br><span class="line"><span class="keyword">if</span>(minnum&gt;bt-&gt;key)</span><br><span class="line">flag=<span class="number">0</span>; </span><br><span class="line">minnum=bt-&gt;key;</span><br><span class="line">inorder(bt-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    2.<strong>设计判断两个二叉树是否相同的算法</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judgebitree</span><span class="params">(bitree *bt1,bitree *bt2)</span><span class="comment">//判断两个二叉树是否相同。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bt1==<span class="number">0</span> &amp;&amp; bt2==<span class="number">0</span>)<span class="comment">//两棵树对应位置都为空返回1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (bt1==<span class="number">0</span> || bt2==<span class="number">0</span> ||bt1-&gt;data!=bt2-&gt;data) </span><br><span class="line">        <span class="comment">//两棵树的当前节点只有一个为空或者两棵树的当前节点的值不同。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  <span class="keyword">return</span> judgebitree(bt1-&gt;lchild,bt2-&gt;lchild)*judgebitree(bt1-&gt;rchild,bt2-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    3.<strong>两个有序单链表的归并算法</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(lk *p1,lk *p2,lk *head1,lk*head2,lk *tail)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//取出第一个链表的头结点</span></span><br><span class="line">    p1 = head1-&gt;next;</span><br><span class="line">    p2 = head2-&gt;next;</span><br><span class="line">    head1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    tail = head1;</span><br><span class="line">    <span class="built_in">free</span>(head2);</span><br><span class="line">    <span class="comment">//比较数据域</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &amp;&amp; p2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p2-&gt;data &gt; p1-&gt;data)&#123;</span><br><span class="line">            tail-&gt;next = p1;</span><br><span class="line">            tail = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>; <span class="comment">//将已经插入的结点的指针域清空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tail-&gt;next = p2;</span><br><span class="line">            tail = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p1)</span><br><span class="line">        tail-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tail-&gt;next = p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    4.<strong>设计在链式存储结构上交换二叉树所有节点左右子树的算法</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125; tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapbitree</span><span class="params">(tree *bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    swapbitree(bt-&gt;lchild); swapbitree(bt-&gt;rchild);  <span class="comment">//先递归，直到叶子节点再从下往上进行互换。</span></span><br><span class="line">    tree *p=bt-&gt;lchild;</span><br><span class="line">    bt-&gt;lchild=bt-&gt;rchild;</span><br><span class="line">    bt-&gt;rchild=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    5.<strong>设计在单链表中删除值相同的多余结点的算法</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>datatype data; <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>&#125;lklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delredundant</span><span class="params">(lklist *&amp;head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lklist *p,*q,*s;</span><br><span class="line">    p=head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="number">0</span> &amp;&amp; p-&gt;next!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">s=p;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(q!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data==q-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">s-&gt;next=q-&gt;next;<span class="comment">//s起辅助作用，通过跟随q移动来辅助删除元素</span></span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">q=s-&gt;next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">s=q;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    6.<strong>设计算法求二叉树的结点个数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>,*<span class="title">right</span>;</span></span><br><span class="line">&#125; btree;</span><br><span class="line"><span class="keyword">int</span> conts;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leaves</span><span class="params">(btree *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        leaves(root-&gt;left);</span><br><span class="line">        conts++;</span><br><span class="line">        leaves(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    7.<strong>求二叉树的深度</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>,*<span class="title">right</span>;</span></span><br><span class="line">&#125; btree;</span><br><span class="line"><span class="keyword">int</span> h1,h2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(btree *root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        h1 = Depth(root-&gt;left);</span><br><span class="line">        h2 = Depth(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> max(h1,h2) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    8.<strong>交换二叉树的左右子树</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>,*<span class="title">right</span>;</span></span><br><span class="line">&#125; btree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span><span class="params">(btree *root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">Exchange(root-&gt;left);</span><br><span class="line">        Exchange(root-&gt;right);</span><br><span class="line">        swap(root-&gt;left,root-&gt;right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>34.<strong>串的三种表示方式</strong>：定长顺序存储表示、堆分配存储表示以及块链顺序存储表示。</p><p>35.<strong>中缀表达式转换为后缀、前缀表达式</strong></p><p>​    给出一个中缀表达式：a+b*c-(d+e) 。<br>​    第一步：按照运算符的优先级对所有的运算单位加括号式子变成：((a+(bc))-(d+e)) 。<br>​    第二步：转换。</p><p>​    <strong>前缀</strong>：把运算符号移动到对应的括号前面<br>​                则变成：-(+(a(bc))+(de))<br>​                把括号去掉：-+abc+de  前缀式子出现</p><p>​    <strong>后缀</strong>：把运算符号移动到对应的括号后面<br>​                则变成：((a(bc))+(de)+)-<br>​                把括号去掉：abc-de+-  后缀式子出现</p><p>36.<strong>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</strong></p><p>​    <strong>四种基本的数据结构</strong>：集合、线性结构、树形结构、图状结构。</p><p>37.<strong>线性表</strong>是最常用且最简单的一种数据结构。简言之，一个线性表是n个数据元素的有限序列。</p><p>​    <strong>栈</strong>(FILO)是限定仅在表尾进行插入或删除操作的线性表。表尾是栈顶，表头是栈底，不含元素的空表称为空栈。</p><p>​    <strong>队列</strong>(FIFO)是一种先进先出的线性表，它只允许在表的一端进行插入，而在另一端进行删除元素。允许插入的一端称为队尾，允许删除的一端称为队头。</p><p>38**.顺序存储结构<strong>（顺序映像）是通过</strong>元素在存储器中的相对位置**来表示数据元素之间的逻辑关系。</p><p>​    <strong>链式存储结构</strong>（非顺序映像）是通过<strong>借助指示元素存储地址的指针</strong>来表示数据元素的逻辑关系。</p><p>39.如果T2是由有序树T转换而来的二叉树，那么T中结点的前序就是T2中结点的前序，T中结点的后序就是T2中结点的中序。</p><p>40.若用一个大小为6的数组来实现<strong>循环队列</strong>，且当前rear和front的值分别为0和3,当从队列中删除一个元素，在加入两个元素后，rear和front的值分别为多少。</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210102184246313.png" alt="image-20210102184246313" style="zoom:67%;" /><p>41-1.设<strong>指针变量 p 指向双向循环链表中的结点 X ,则删除结点 X</strong> 需要执行的语句序列为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;l-&gt;r = p-&gt;r;</span><br><span class="line">p-&gt;r-&gt;l = p-&gt;l;</span><br></pre></td></tr></table></figure><p>41-2.双向链表中，<strong>在指针p指向的结点前插入指针q指向的结点</strong>的操作是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q-&gt;next = p;</span><br><span class="line">q-&gt;pre = p-&gt;pre;</span><br><span class="line">p-&gt;pre-&gt;next = q;</span><br><span class="line">p-&gt;pre = q;</span><br></pre></td></tr></table></figure><p>43.设有一个顺序循环队列中有M个存储单元，则该循环队列中最多能够存储 <strong>m-1</strong> 个队列元素；<br>    当前实际存储 <strong>(R-F+M)%M</strong> 个队列元素。<br>[设<strong>头指针F指向当前队头元素的前一个位置</strong>(m-1的原因)，尾指针指向当前队尾元素的位置]</p><p>​    <strong>关于循环队列</strong>：</p><p>​    1.初始时：Q.front = Q.rear = 0;</p><p>​    2.判断队为空：Q.front = Q.rear;</p><p>​    3.判断队为满：(Q.rear + 1)%maxsize = Q.front;</p><p>​    4.出队：Q.front = (Q.front + 1)%maxsize;</p><p>​    5.入队：Q.rear = (Q.rear + 1)%maxsize;</p><p>​    6.判断循环队列元素个数：(Q.rear - Q.front + maxsize)%maxsize.</p><p>44.<strong>广义表</strong>LS=( ( ) , ( e ) , ( a , ( b , c , d ) ) )的头尾链表存储结构。（深度为3）</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210103103508119.png" alt="image-20210103103508119" style="zoom: 60%;" /><p>​    <strong>广义表的深度就是所包含括号的层数</strong>，同级括号属于一个深度。<br>​    比如说C=(a,(b,c,(d)))的深度是3，但是C=(a,(b,c),(d))的深度是2。</p><p>45.影响<strong>哈希表</strong>查找效率的三个因素：哈希函数，处理冲突的方法和哈希表的装填因子。</p><p>​    处理冲突方法相同的哈希表，其平均查找长度依赖于哈希表的装填因子。</p><p>​    哈希表<strong>装填因子</strong>定义为：表中装入的记录数与表的长度的比值。</p><blockquote><p>加载因子是表示Hsah表中元素的填满的程度.<br>若:加载因子越大,填满的元素越多。好处是:空间利用率高了，但:冲突的机会加大了。<br>反之,加载因子越小,填满的元素越少。好处是:冲突的机会减小了,但:空间浪费多了.</p></blockquote><p>46.<strong>稀疏矩阵的压缩存储方式</strong>：</p><p>​    三元组顺序表，行逻辑连接的顺序表，十字链表。</p><p>47.堆是一种选择排序。选择排序分为直接选择排序和堆排序。</p><p>​    对n个不同的关键字进行冒泡排序，在元素无序的情况下比较次数为 n(n-1)/2。</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210103115353338.png" alt="image-20210103115353338" style="zoom: 55%;" /><p>​    与快速排序和堆排序相比，归并排序的最大特点是：稳定</p><p>​    48.设一组初始记录关键字序列为(25，50，15，35，80，85，20，40，36，70)，其中含有5个长度为2的有序子表，则用归并排序的方法对该记录关键字序列<strong>进行一趟归并后的结果</strong>为 ( A )。 </p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210103181036619.png" alt="image-20210103181036619" style="zoom:67%;" /><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210103181121768.png" alt="image-20210103181121768" style="zoom:67%;" /><p>49.在图的<strong>邻接表中用顺序存储结构存储表头结点的优点</strong>是：可以随机访问到任一个顶点的简单链表。</p><p>50.<strong>算法填空</strong>：</p><p>​    1.冒泡排序</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210103190746127.png" alt="image-20210103190746127" style="zoom: 67%;" /><p>​    2.二分查找</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210103191032909_看图王.png" alt="image-20210103191032909" style="zoom: 67%;" /><p>51.设一组权值集合 W={2 , 3 , 4 , 5 , 6} ,则由该权值集合构造的哈夫曼树中<strong>带权路径长度</strong>之和为（45）。</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210103202856209.png" alt="image-20210103202856209" style="zoom: 60%;" /><p>​    带权路径 = 2 * 3 + 3 * 2 + 4 * 2 + 5 * 2 + 6 * 2  （带权路径长度等于权值乘路径长度）。</p><p>53.<strong>完全二叉树</strong>的叶子结点总比内结点多一个。（知道总结点和叶子结点可用此方法）</p><p>​    一般二叉树常用 <strong>n0 = n2 + 1</strong>来计算结点数。</p><p>54.设某无向图中有 n 个顶点 e 条边,则建立该图邻接表的时间复杂度为O(n+e)。</p><p>​    设二叉排序树上有 n 个结点,则在二叉排序树上查找结点的平均时间复杂度为O(log2n)，最坏为O(n)。</p><p>55.<strong>散列表中解决冲突的方法</strong>是：开放定址法，链地址法。</p><p>56.假定一个初始堆为(1, 5, 3, 9, 12, 7, 15, 10)，则进行<strong>第一趟堆排序</strong>后得到的结果为（ A ）。<br>                 A. 3, 5, 7, 9, 12, 10, 15, 1        B. 3, 5, 9, 7, 12, 10, 15, 1<br>                 C. 3, 7, 5, 9, 12, 10, 15, 1        D. 3, 5, 7, 12, 9, 10, 15, 1</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210104192559095.png" alt="image-20210104192559095" style="zoom:80%;" /><p>57.<strong>连通分量是无向图的极大连通子图</strong>。</p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210104204304278.png" alt="image-20210104204304278" style="zoom:110%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构复习整理&quot;&gt;&lt;a href=&quot;#数据结构复习整理&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习整理&quot;&gt;&lt;/a&gt;数据结构复习整理&lt;/h1&gt;&lt;p&gt;1.选A。&lt;/p&gt;
&lt;img src=&quot;C:\Users\user\AppData\Roam</summary>
      
    
    
    
    
    <category term="Data Structure" scheme="https://theaseven.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>javaweb node1</title>
    <link href="https://theaseven.github.io/2020/11/13/javaweb%20node1/"/>
    <id>https://theaseven.github.io/2020/11/13/javaweb%20node1/</id>
    <published>2020-11-13T12:13:28.000Z</published>
    <updated>2020-11-13T14:01:58.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两种UTILS及其简单示例"><a href="#两种UTILS及其简单示例" class="headerlink" title="两种UTILS及其简单示例"></a>两种UTILS及其简单示例</h1><p><em>放个关于 PreparedStatement和 Statement的链接：<a href="https://blog.csdn.net/czh500/article/details/88202971?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-2&spm=1001.2101.3001.4242">csdn - java中PreparedStatement和Statement详细讲解</a></em><br>这篇文章主要用来记录下两个常用的UTILS，防丢（-.-）。</p><h2 id="1-JDBC"><a href="#1-JDBC" class="headerlink" title="1.JDBC"></a>1.JDBC</h2><blockquote><p>jdbc简介：</p><p>JDBC API 允许用户访问任何形式的表格数据，尤其是存储在关系数据库中的数据。</p><p>执行流程：</p><ul><li>连接数据源，如：数据库。</li><li>为数据库传递查询和更新指令。</li><li>处理数据库响应并返回的结果。</li></ul></blockquote><p><strong>实例（登录案例）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> util.DemoUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo9Transaction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt1 = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 定义 ：张三-500，李四+500</span></span><br><span class="line">            conn = DemoUtils.getConnection();</span><br><span class="line">            <span class="comment">// 开启事务</span></span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            String sql1 = <span class="string">&quot;update account set balance = balance - ? where id = ?&quot;</span>;</span><br><span class="line">            String sql2 = <span class="string">&quot;update account set balance = balance + ? where id = ?&quot;</span>;</span><br><span class="line">            <span class="comment">// 获取执行sql对象</span></span><br><span class="line">            pstmt1 = conn.prepareStatement(sql1);</span><br><span class="line">            pstmt2 = conn.prepareStatement(sql2);</span><br><span class="line">            <span class="comment">// 设置参数(填充？, 1、2代表第几个？)</span></span><br><span class="line">            pstmt1.setInt(<span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line">            pstmt1.setString(<span class="number">2</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">            pstmt2.setInt(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pstmt2.setString(<span class="number">2</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">            pstmt1.executeUpdate();</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">            pstmt2.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  <span class="comment">// 抓取的异常要大</span></span><br><span class="line">            <span class="comment">// 事务回滚(返回到异常开始之前的状态)</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e2) &#123;</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DemoUtils.close(conn, pstmt1);</span><br><span class="line">            DemoUtils.close(<span class="keyword">null</span>, pstmt2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>utils :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件读取，使用静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Properties集合类</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">// 获取src路径下的文件的路径</span></span><br><span class="line">            ClassLoader classLoader = DemoUtils.class.getClassLoader();</span><br><span class="line">            URL res = classLoader.getResource(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">            String path = res.getPath();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加载文件</span></span><br><span class="line">            pro.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">            <span class="comment">// 获取数据，赋值</span></span><br><span class="line">            url = pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            user = pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            password = pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            driver = pro.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">            <span class="comment">// 注册驱动</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;  <span class="comment">// 获取连接</span></span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, Statement stmt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, PreparedStatement pstmt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pstmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pstmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, Statement stmt, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">if</span>(stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Druid-数据库连接池"><a href="#2-Druid-数据库连接池" class="headerlink" title="2.Druid(数据库连接池)"></a>2.Druid(数据库连接池)</h2><blockquote><p><em>druid</em>为阿里巴巴的数据源,(数据库连接池),集合了c3p0、dbcp、proxool等连接池的优点。</p><p>Druid首先是一个数据库连接池。Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource。Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</p><p>功能：数据库连接池子，监控，加密，扩展日志。</p></blockquote><p>Druid详解指路——<a href="https://blog.csdn.net/bluejoe2000/article/details/53725399">csdn-Druid(大数据实时统计分析数据存储)</a></p><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dataSourse.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> utils.druid_utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = druid_utils.getConnection();</span><br><span class="line">            String sql = <span class="string">&quot;insert into account values(?,?)&quot;</span>;</span><br><span class="line">            pstmt = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">// 给？赋值</span></span><br><span class="line">            pstmt.setString(<span class="number">1</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">            pstmt.setInt(<span class="number">2</span>,<span class="number">20000</span>);</span><br><span class="line">            <span class="comment">// 执行sql</span></span><br><span class="line">            <span class="keyword">int</span> count = pstmt.executeUpdate();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            druid_utils.close(pstmt ,conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>utils：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">druid_utils</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义成员变量 DataSource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载配置文件</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            pro.load(druid_utils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取DataSource(连接对象)</span></span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt, Connection conn)</span> </span>&#123;</span><br><span class="line">        close(<span class="keyword">null</span>, stmt, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(PreparedStatement pstmt, Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pstmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pstmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs, Statement stmt, Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">if</span>(stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接池方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两种UTILS及其简单示例&quot;&gt;&lt;a href=&quot;#两种UTILS及其简单示例&quot; class=&quot;headerlink&quot; title=&quot;两种UTILS及其简单示例&quot;&gt;&lt;/a&gt;两种UTILS及其简单示例&lt;/h1&gt;&lt;p&gt;&lt;em&gt;放个关于 PreparedStatement</summary>
      
    
    
    
    
    <category term="javaweb" scheme="https://theaseven.github.io/tags/javaweb/"/>
    
  </entry>
  
  <entry>
    <title>2020实训测试数据</title>
    <link href="https://theaseven.github.io/2020/11/11/2020%E5%AE%9E%E8%AE%AD%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/"/>
    <id>https://theaseven.github.io/2020/11/11/2020%E5%AE%9E%E8%AE%AD%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/</id>
    <published>2020-11-11T12:29:02.000Z</published>
    <updated>2021-01-11T12:40:16.574Z</updated>
    
    <content type="html"><![CDATA[<p>数据集（测试数据）</p><p>输入包括：</p><p>point_num点(坐标)范围</p><p>line_num路线数</p><p>station_num站点数目</p><p>依据站点数目输入对应成对的x、y坐标</p><p>id(车辆)</p><p>value价格</p><p>speed速度</p><p>wait time等待时间</p><p>start time 开始时间</p><p>end time 结束时间</p><p>100</p><p>6</p><p>10</p><p>1 1</p><p>第一站</p><p>14 12</p><p>第二站</p><p>17 24</p><p>第三站</p><p>27 35</p><p>第四站</p><p>34 39</p><p>第五站</p><p>41 46</p><p>第六站</p><p>53 42</p><p>第七站</p><p>62 46</p><p>第八站</p><p>67 39</p><p>第九站</p><p>74 47</p><p>第十站</p><p>1</p><p>4</p><p>3</p><p>6</p><p>0</p><p>10000</p><p>10</p><p>1 1</p><p>第一站</p><p>5 10</p><p>第二站</p><p>6 32</p><p>第三站</p><p>14 16</p><p>第四站</p><p>25 19</p><p>第五站</p><p>24 34</p><p>第六站</p><p>30 52</p><p>第七站</p><p>38 47</p><p>第八站</p><p>53 42</p><p>第九站</p><p>71 49</p><p>第十站</p><p>2</p><p>2</p><p>2</p><p>10</p><p>0</p><p>10000</p><p>8</p><p>6 32</p><p>第一站</p><p>12 14</p><p>第二站</p><p>21 27</p><p>第三站</p><p>24 34</p><p>第四站</p><p>31 49</p><p>第五站</p><p>42 42</p><p>第六站</p><p>53 42</p><p>第七站</p><p>67 39</p><p>第八站</p><p>3</p><p>2</p><p>3</p><p>15</p><p>0</p><p>10000</p><p>10</p><p>1 1</p><p>第一站</p><p>12 7</p><p>第二站</p><p>21 27</p><p>第三站</p><p>31 32</p><p>第四站</p><p>34 39</p><p>第五站</p><p>24 34</p><p>第六站</p><p>30 52</p><p>第七站</p><p>35 46</p><p>第八站</p><p>42 42</p><p>第九站</p><p>53 42</p><p>第十站</p><p>4</p><p>4</p><p>2</p><p>12</p><p>0</p><p>10000</p><p>12</p><p>1 1</p><p>第一站</p><p>3 10</p><p>第二站</p><p>10 5</p><p>第三站</p><p>12 7</p><p>第四站</p><p>14 16</p><p>第五站</p><p>25 20</p><p>第六站</p><p>34 37</p><p>第七站</p><p>41 46</p><p>第八站</p><p>34 39</p><p>第九站</p><p>45 45</p><p>第十站</p><p>53 42</p><p>第十一站</p><p>61 50</p><p>第十二站</p><p>5</p><p>2</p><p>2</p><p>14</p><p>0</p><p>10000</p><p>10</p><p>1 1</p><p>第一站</p><p>4 16</p><p>第二站</p><p>7 21</p><p>第三站</p><p>21 27</p><p>第四站</p><p>27 31</p><p>第五站</p><p>34 37</p><p>第六站</p><p>41 46</p><p>第七站</p><p>43 52</p><p>第八站</p><p>53 42</p><p>第九站</p><p>67 39</p><p>第十站</p><p>6</p><p>5</p><p>4</p><p>6</p><p>0</p><p>10000</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据集（测试数据）&lt;/p&gt;
&lt;p&gt;输入包括：&lt;/p&gt;
&lt;p&gt;point_num点(坐标)范围&lt;/p&gt;
&lt;p&gt;line_num路线数&lt;/p&gt;
&lt;p&gt;station_num站点数目&lt;/p&gt;
&lt;p&gt;依据站点数目输入对应成对的x、y坐标&lt;/p&gt;
&lt;p&gt;id(车辆)&lt;/p&gt;
&lt;p&gt;v</summary>
      
    
    
    
    
    <category term="实训" scheme="https://theaseven.github.io/tags/%E5%AE%9E%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>Welcome</title>
    <link href="https://theaseven.github.io/2020/11/05/Welcome/"/>
    <id>https://theaseven.github.io/2020/11/05/Welcome/</id>
    <published>2020-11-05T08:25:07.000Z</published>
    <updated>2020-11-05T12:56:29.869Z</updated>
    
    <content type="html"><![CDATA[<p>Hello，I’m theaseven.</p><a id="more"></a><p>第一个博客的诞生。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hello，I’m theaseven.&lt;/p&gt;</summary>
    
    
    
    
    <category term="free" scheme="https://theaseven.github.io/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://theaseven.github.io/2020/11/03/hello-world/"/>
    <id>https://theaseven.github.io/2020/11/03/hello-world/</id>
    <published>2020-11-03T11:34:37.828Z</published>
    <updated>2020-11-05T12:53:28.398Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
